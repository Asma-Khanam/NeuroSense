# -*- coding: utf-8 -*-
"""2.1 EEG ML classification_asma.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZmU67jB2X8xfkf9WqrU0ouS7q5VaAkQv

LR done
"""

pip install mne

from glob import glob
import os
import mne
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

#read all file
all_files_path=glob('h3.csv')
print(len(all_files_path))

import numpy as np
import mne
edf = mne.io.read_raw_edf('/content/S001R01.edf')
header = ','.join(edf.ch_names)
np.savetxt('h3.csv', edf.get_data().T, delimiter=',', header=header)

csv_data= pd.read_csv('h3.csv')

csv_data.head()

csv_data.tail()

import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv("h3.csv")  # replace with your actual path
df.columns = ['Fp2', 'F8', 'T4', 'T6', 'O2', 'Fp1', 'F7', 'T3', 'T5', 'O1',
              'F4', 'C4', 'P4', 'F3', 'C3', 'P3', 'Fz', 'Cz', 'Pz']

df[['Fp1', 'Fz', 'Cz']].plot(figsize=(15,5))
plt.title("EEG signals from Fp1, Fz, Cz")
plt.xlabel("Time (samples)")
plt.ylabel("Voltage (V)")
plt.show()

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np

# Load the data
df = pd.read_csv("h3.csv")  # replace with your actual path

# Set column names for the 19 channels
df.columns = ['Fp2', 'F8', 'T4', 'T6', 'O2', 'Fp1', 'F7', 'T3', 'T5', 'O1',
              'F4', 'C4', 'P4', 'F3', 'C3', 'P3', 'Fz', 'Cz', 'Pz']

# Create a figure with subplots for each channel
n_channels = len(df.columns)
fig, axes = plt.subplots(n_channels, 1, figsize=(15, 3*n_channels), sharex=True)
fig.tight_layout(pad=3.0)

# Plot each channel separately
for i, channel in enumerate(df.columns):
    axes[i].plot(df[channel], linewidth=1)
    axes[i].set_title(f"Channel: {channel}")
    axes[i].set_ylabel("Voltage (V)")

# Set the x-axis label only on the bottom subplot
axes[-1].set_xlabel("Time (samples)")

plt.suptitle("EEG Channel Signals", fontsize=16)
plt.subplots_adjust(top=0.95)
plt.show()

# Alternative approach: Create individual plots for each channel
# This will generate 19 separate figures
def plot_individual_channels(dataframe, save_figs=False):
    for channel in dataframe.columns:
        plt.figure(figsize=(15, 4))
        plt.plot(dataframe[channel], linewidth=1)
        plt.title(f"EEG Signal: {channel}")
        plt.xlabel("Time (samples)")
        plt.ylabel("Voltage (V)")
        plt.grid(True, alpha=0.3)

        if save_figs:
            plt.savefig(f"EEG_channel_{channel}.png", dpi=300, bbox_inches='tight')

        plt.show()

# Uncomment this line to run the individual plots approach
plot_individual_channels(df)

# Plot only motor cortex channels
motor_channels = ['C3', 'Cz', 'C4']
plt.figure(figsize=(15, 8))

for channel in motor_channels:
    plt.plot(df[channel], label=channel)

plt.title("Motor Cortex EEG Signals")
plt.xlabel("Time (samples)")
plt.ylabel("Voltage (V)")
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

all_files_path[0]

healthy_file_path = [i for i in all_files_path if 'h' in i]
patient_file_path = [i for i in all_files_path if 's' in i]

from google.colab import drive
drive.mount('/content/drive')

def read_data(file_path):
    datax=mne.io.read_raw_edf(file_path,preload=True)
    datax.set_eeg_reference()
    datax.filter(l_freq=1,h_freq=45)
    epochs=mne.make_fixed_length_epochs(datax,duration=25,overlap=0)
    epochs=epochs.get_data()
    return epochs #trials,channel,length

import pandas as pd
import numpy as np

def read_csv_data(file_path):
    df = pd.read_csv(file_path)
    data = df.values  # Convert DataFrame to NumPy array

    # If needed, reshape or manipulate to match (trials, channels, length) format
    # Here you might need to reshape depending on how your CSV is structured
    return data

data = read_csv_data(healthy_file_path[0])

data=read_csv_data(healthy_file_path[0])

data.shape

import pandas as pd
import numpy as np
from scipy.signal import butter, lfilter

def butter_bandpass_filter(data, lowcut, highcut, fs, order=5):
    nyquist = 0.5 * fs
    low = lowcut / nyquist
    high = highcut / nyquist
    b, a = butter(order, [low, high], btype='band')
    y = lfilter(b, a, data, axis=0)
    return y

def read_csv_eeg(file_path, fs=256):  # You can adjust fs (sampling freq)
    df = pd.read_csv(file_path)

    # Drop non-EEG columns if needed (e.g., time, markers)
    eeg_data = df.select_dtypes(include=[np.number]).values

    # Bandpass filter between 1-45 Hz
    eeg_filtered = butter_bandpass_filter(eeg_data, 1, 45, fs)

    # Convert into fixed-length epochs (25s with no overlap)
    epoch_len = fs * 25
    total_len = eeg_filtered.shape[0]
    n_epochs = total_len // epoch_len

    # Trim to fit complete epochs only
    eeg_trimmed = eeg_filtered[:n_epochs * epoch_len]
    epochs = eeg_trimmed.reshape(n_epochs, epoch_len, -1).transpose(0, 2, 1)  # (epochs, channels, time)

    return epochs

control_epochs_array = [read_csv_eeg(subject) for subject in healthy_file_path]
patients_epochs_array = [read_csv_eeg(subject) for subject in patient_file_path]
print(len(control_epochs_array),len(patients_epochs_array))

control_epochs_labels = [len(epochs) * [0] for epochs in control_epochs_array]
patients_epochs_labels = [len(epochs) * [1] for epochs in patients_epochs_array]

print("Number of subjects: ", len(control_epochs_labels), len(patients_epochs_labels))

# Combine arrays and labels
# -----------------------------
data_list = control_epochs_array + patients_epochs_array
label_list = control_epochs_labels + patients_epochs_labels

print("Data subject lists combined:", len(data_list), "Label subject lists combined:", len(label_list))

# Grouping (for Leave-One-Subject-Out CV etc.)
# -----------------------------
groups_list = [[i] * len(epochs) for i, epochs in enumerate(data_list)]

# Flatten into single array
# -----------------------------
data_array = np.vstack(data_list)
label_array = np.hstack(label_list)
group_array = np.hstack(groups_list)

print("Final shapes ‚Äî Data:", data_array.shape, "Labels:", label_array.shape, "Groups:", group_array.shape)

from scipy import stats
def mean(data):
    return np.mean(data,axis=-1)

def std(data):
    return np.std(data,axis=-1)

def ptp(data):
    return np.ptp(data,axis=-1)

def var(data):
        return np.var(data,axis=-1)

def minim(data):
      return np.min(data,axis=-1)


def maxim(data):
      return np.max(data,axis=-1)

def argminim(data):
      return np.argmin(data,axis=-1)


def argmaxim(data):
      return np.argmax(data,axis=-1)

def mean_square(data):
      return np.mean(data**2,axis=-1)

def rms(data): #root mean square
      return  np.sqrt(np.mean(data**2,axis=-1))

def abs_diffs_signal(data):
    return np.sum(np.abs(np.diff(data,axis=-1)),axis=-1)


def skewness(data):
    return stats.skew(data,axis=-1)

def kurtosis(data):
    return stats.kurtosis(data,axis=-1)

def concatenate_features(data):
    return np.concatenate((mean(data),std(data),ptp(data),var(data),minim(data),maxim(data),argminim(data),argmaxim(data),
                          mean_square(data),rms(data),abs_diffs_signal(data),
                          skewness(data),kurtosis(data)),axis=-1)

from tqdm import tqdm_notebook
features=[]
for data in tqdm_notebook(data_array):
    features.append(concatenate_features(data))
features=np.array(features)
features.shape

from sklearn.linear_model import LogisticRegression
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import GroupKFold,GridSearchCV,cross_val_score,cross_validate

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(features, label_array, test_size=0.3, random_state=42, stratify=label_array)

pipe = Pipeline([('scaler', StandardScaler()), ('classifier', LogisticRegression())])
param_grid = {'classifier__C': [0.01, 0.1, 1, 10]}

gscv = GridSearchCV(pipe, param_grid, cv=3, n_jobs=-1, verbose=1)
gscv.fit(X_train, y_train)

print("Best score:", gscv.best_score_)
print("Test score:", gscv.score(X_test, y_test))

gscv.best_score_

from IPython.display import display, HTML
import numpy as np

# Simulated model prediction
prediction = 1  # Example (1 = Move, 0 = Rest)

def show_popup_jupyter(label):
    if label == 1:
        display(HTML("<h3 style='color: green;'>üö∂‚Äç‚ôÇÔ∏è Move Detected!</h3>"))
    else:
        display(HTML("<h3 style='color: blue;'>ü™ë Rest Detected!</h3>"))

show_popup_jupyter(prediction)

